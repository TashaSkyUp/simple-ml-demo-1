<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU Performance Diagnostic</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .test-section {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .pass { color: #00ff00; }
        .fail { color: #ff4444; }
        .warn { color: #ffaa00; }
        .info { color: #4488ff; }
        .perf-good { color: #00ff00; font-weight: bold; }
        .perf-bad { color: #ff4444; font-weight: bold; }
        .perf-ok { color: #ffaa00; font-weight: bold; }
        .code {
            background: #000;
            padding: 10px;
            border-left: 3px solid #444;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 12px;
        }
        button {
            background: #333;
            color: #00ff00;
            border: 1px solid #555;
            padding: 10px 20px;
            cursor: pointer;
            margin: 5px;
            border-radius: 3px;
        }
        button:hover {
            background: #444;
        }
        button:disabled {
            background: #222;
            color: #666;
            cursor: not-allowed;
        }
        .benchmark-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .benchmark-card {
            background: #001122;
            border: 1px solid #004466;
            padding: 15px;
            border-radius: 5px;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #88ff88);
            width: 0%;
            transition: width 0.3s ease;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        .comparison-table th,
        .comparison-table td {
            border: 1px solid #444;
            padding: 8px;
            text-align: left;
        }
        .comparison-table th {
            background: #333;
        }
        .winner {
            background: #003300;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ WebGPU Performance Diagnostic</h1>
        <p class="info">Advanced performance analysis to understand why WebGPU might be slower than expected.</p>

        <div class="test-section">
            <h2>üìä System Performance Profile</h2>
            <div id="system-profile">
                <div>üñ•Ô∏è Platform: <span id="platform"></span></div>
                <div>üîß Hardware Concurrency: <span id="cores"></span> cores</div>
                <div>üíæ Device Memory: <span id="memory"></span></div>
                <div>üïê Performance Now Resolution: <span id="timer-resolution"></span></div>
            </div>
        </div>

        <div class="test-section">
            <h2>üéØ Backend Configuration Analysis</h2>
            <div id="backend-analysis"></div>
            <button onclick="analyzeBackends()">Analyze Backend Configurations</button>
        </div>

        <div class="test-section">
            <h2>‚ö° Detailed Performance Benchmarks</h2>
            <div class="benchmark-grid">
                <div class="benchmark-card">
                    <h3>üßÆ Matrix Operations</h3>
                    <div id="matrix-benchmark">
                        <div>Small (64x64): <span id="matrix-small">Not tested</span></div>
                        <div>Medium (256x256): <span id="matrix-medium">Not tested</span></div>
                        <div>Large (512x512): <span id="matrix-large">Not tested</span></div>
                    </div>
                    <button onclick="runMatrixBenchmarks()">Test Matrix Ops</button>
                </div>

                <div class="benchmark-card">
                    <h3>üîÑ Convolution Operations</h3>
                    <div id="conv-benchmark">
                        <div>Conv2D 3x3: <span id="conv-3x3">Not tested</span></div>
                        <div>Conv2D 5x5: <span id="conv-5x5">Not tested</span></div>
                        <div>DepthwiseConv: <span id="conv-dw">Not tested</span></div>
                    </div>
                    <button onclick="runConvBenchmarks()">Test Convolutions</button>
                </div>

                <div class="benchmark-card">
                    <h3>üìä Memory Transfer</h3>
                    <div id="memory-benchmark">
                        <div>CPU‚ÜíGPU: <span id="mem-upload">Not tested</span></div>
                        <div>GPU‚ÜíCPU: <span id="mem-download">Not tested</span></div>
                        <div>GPU‚ÜíGPU: <span id="mem-copy">Not tested</span></div>
                    </div>
                    <button onclick="runMemoryBenchmarks()">Test Memory Transfer</button>
                </div>

                <div class="benchmark-card">
                    <h3>üî¢ Tensor Creation</h3>
                    <div id="tensor-benchmark">
                        <div>Small tensors: <span id="tensor-small">Not tested</span></div>
                        <div>Large tensors: <span id="tensor-large">Not tested</span></div>
                        <div>Disposal speed: <span id="tensor-disposal">Not tested</span></div>
                    </div>
                    <button onclick="runTensorBenchmarks()">Test Tensor Ops</button>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>üîç CNN-Specific Performance</h2>
            <div id="cnn-analysis">
                <p>This test mimics the exact operations used in your CNN trainer:</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="cnn-progress"></div>
                </div>
                <div id="cnn-results"></div>
            </div>
            <button onclick="runCNNSpecificTest()" id="cnn-test-btn">Run CNN Performance Test</button>
        </div>

        <div class="test-section">
            <h2>üìà Performance Comparison</h2>
            <table class="comparison-table" id="comparison-table">
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>WebGPU (ops/sec)</th>
                        <th>WebGL (ops/sec)</th>
                        <th>CPU (ops/sec)</th>
                        <th>Winner</th>
                        <th>Analysis</th>
                    </tr>
                </thead>
                <tbody id="comparison-body">
                    <tr><td colspan="6" class="info">Run benchmarks to see comparison</td></tr>
                </tbody>
            </table>
        </div>

        <div class="test-section">
            <h2>üîß Performance Issues & Solutions</h2>
            <div id="performance-issues"></div>
        </div>

        <div class="test-section">
            <h2>üí° Optimization Recommendations</h2>
            <div id="optimization-recommendations"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgpu@4.22.0/dist/tf-backend-webgpu.min.js"></script>

    <script>
        let benchmarkResults = {};

        // Initialize system info
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('platform').textContent = navigator.platform;
            document.getElementById('cores').textContent = navigator.hardwareConcurrency || 'Unknown';
            document.getElementById('memory').textContent = navigator.deviceMemory ? `${navigator.deviceMemory} GB` : 'Unknown';

            // Test timer resolution
            const start = performance.now();
            const resolution = performance.now() - start;
            document.getElementById('timer-resolution').textContent = `${resolution.toFixed(6)}ms`;
        });

        function log(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            const className = type === 'pass' ? 'pass' : type === 'fail' ? 'fail' : type === 'warn' ? 'warn' : 'info';
            if (element) {
                element.innerHTML += `<div class="${className}">${message}</div>`;
            }
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function formatPerformance(opsPerSec) {
            if (opsPerSec > 1000) return `<span class="perf-good">${opsPerSec.toFixed(0)} ops/sec</span>`;
            if (opsPerSec > 100) return `<span class="perf-ok">${opsPerSec.toFixed(0)} ops/sec</span>`;
            return `<span class="perf-bad">${opsPerSec.toFixed(0)} ops/sec</span>`;
        }

        async function analyzeBackends() {
            const analysisDiv = document.getElementById('backend-analysis');
            analysisDiv.innerHTML = '<div class="info">üîÑ Analyzing backend configurations...</div>';

            try {
                await tf.ready();

                const backends = ['webgpu', 'webgl', 'cpu'];
                for (const backend of backends) {
                    try {
                        await tf.setBackend(backend);
                        const currentBackend = tf.getBackend();

                        if (currentBackend === backend) {
                            log('backend-analysis', `‚úÖ ${backend.toUpperCase()}: Successfully switched`, 'pass');

                            // Get backend-specific info
                            if (backend === 'webgpu') {
                                const gpuBackend = tf.backend();
                                if (gpuBackend && gpuBackend.device) {
                                    log('backend-analysis', `   üéØ WebGPU Device: ${gpuBackend.device.label || 'unlabeled'}`, 'info');
                                }

                                // Check WebGPU features
                                if (navigator.gpu) {
                                    const adapter = await navigator.gpu.requestAdapter();
                                    if (adapter) {
                                        const features = Array.from(adapter.features);
                                        log('backend-analysis', `   üéØ WebGPU Features: ${features.length} available`, 'info');
                                        if (features.includes('timestamp-query')) {
                                            log('backend-analysis', `   ‚è±Ô∏è Timestamp queries: Available`, 'pass');
                                        } else {
                                            log('backend-analysis', `   ‚è±Ô∏è Timestamp queries: Not available (may affect performance measurement)`, 'warn');
                                        }
                                    }
                                }
                            } else if (backend === 'webgl') {
                                const webglBackend = tf.backend();
                                if (webglBackend && webglBackend.gpgpu && webglBackend.gpgpu.gl) {
                                    const gl = webglBackend.gpgpu.gl;
                                    log('backend-analysis', `   üéØ WebGL Vendor: ${gl.getParameter(gl.VENDOR)}`, 'info');
                                    log('backend-analysis', `   üéØ WebGL Renderer: ${gl.getParameter(gl.RENDERER)}`, 'info');
                                    log('backend-analysis', `   üéØ Max Texture Size: ${gl.getParameter(gl.MAX_TEXTURE_SIZE)}`, 'info');
                                }
                            }

                            // Check memory usage
                            const memInfo = tf.memory();
                            log('backend-analysis', `   üíæ Memory: ${memInfo.numTensors} tensors, ${(memInfo.numBytes / 1024 / 1024).toFixed(2)} MB`, 'info');

                        } else {
                            log('backend-analysis', `‚ùå ${backend.toUpperCase()}: Failed to switch (using ${currentBackend})`, 'fail');
                        }

                        // Clean up any tensors
                        tf.disposeVariables();

                    } catch (error) {
                        log('backend-analysis', `‚ùå ${backend.toUpperCase()}: Error - ${error.message}`, 'fail');
                    }
                }

            } catch (error) {
                log('backend-analysis', `‚ùå Backend analysis failed: ${error.message}`, 'fail');
            }
        }

        async function benchmarkOperation(name, operation, iterations = 50) {
            const results = {};
            const backends = ['webgpu', 'webgl', 'cpu'];

            for (const backend of backends) {
                try {
                    await tf.setBackend(backend);
                    if (tf.getBackend() !== backend) {
                        results[backend] = 0;
                        continue;
                    }

                    // Warmup
                    for (let i = 0; i < 3; i++) {
                        const tensors = await operation();
                        tensors.forEach(t => t.dispose());
                    }

                    // Benchmark
                    const startTime = performance.now();
                    for (let i = 0; i < iterations; i++) {
                        const tensors = await operation();
                        await Promise.all(tensors.map(t => t.data())); // Ensure completion
                        tensors.forEach(t => t.dispose());
                    }
                    const endTime = performance.now();

                    results[backend] = iterations / ((endTime - startTime) / 1000);

                } catch (error) {
                    console.warn(`${backend} failed for ${name}:`, error);
                    results[backend] = 0;
                }
            }

            benchmarkResults[name] = results;
            return results;
        }

        async function runMatrixBenchmarks() {
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Testing...';

            try {
                // Small matrix multiplication
                let results = await benchmarkOperation('matrix-small', () => {
                    const a = tf.randomNormal([64, 64]);
                    const b = tf.randomNormal([64, 64]);
                    return [tf.matMul(a, b)];
                }, 30);
                document.getElementById('matrix-small').innerHTML =
                    `GPU: ${formatPerformance(results.webgpu)}, GL: ${formatPerformance(results.webgl)}, CPU: ${formatPerformance(results.cpu)}`;

                // Medium matrix multiplication
                results = await benchmarkOperation('matrix-medium', () => {
                    const a = tf.randomNormal([256, 256]);
                    const b = tf.randomNormal([256, 256]);
                    return [tf.matMul(a, b)];
                }, 10);
                document.getElementById('matrix-medium').innerHTML =
                    `GPU: ${formatPerformance(results.webgpu)}, GL: ${formatPerformance(results.webgl)}, CPU: ${formatPerformance(results.cpu)}`;

                // Large matrix multiplication
                results = await benchmarkOperation('matrix-large', () => {
                    const a = tf.randomNormal([512, 512]);
                    const b = tf.randomNormal([512, 512]);
                    return [tf.matMul(a, b)];
                }, 5);
                document.getElementById('matrix-large').innerHTML =
                    `GPU: ${formatPerformance(results.webgpu)}, GL: ${formatPerformance(results.webgl)}, CPU: ${formatPerformance(results.cpu)}`;

            } finally {
                button.disabled = false;
                button.textContent = 'Test Matrix Ops';
                updateComparisonTable();
            }
        }

        async function runConvBenchmarks() {
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Testing...';

            try {
                // 3x3 convolution
                let results = await benchmarkOperation('conv-3x3', () => {
                    const input = tf.randomNormal([1, 28, 28, 1]);
                    const filter = tf.randomNormal([3, 3, 1, 8]);
                    return [tf.conv2d(input, filter, 1, 'same')];
                }, 20);
                document.getElementById('conv-3x3').innerHTML =
                    `GPU: ${formatPerformance(results.webgpu)}, GL: ${formatPerformance(results.webgl)}, CPU: ${formatPerformance(results.cpu)}`;

                // 5x5 convolution
                results = await benchmarkOperation('conv-5x5', () => {
                    const input = tf.randomNormal([1, 28, 28, 1]);
                    const filter = tf.randomNormal([5, 5, 1, 16]);
                    return [tf.conv2d(input, filter, 1, 'same')];
                }, 15);
                document.getElementById('conv-5x5').innerHTML =
                    `GPU: ${formatPerformance(results.webgpu)}, GL: ${formatPerformance(results.webgl)}, CPU: ${formatPerformance(results.cpu)}`;

                // Depthwise convolution
                results = await benchmarkOperation('conv-dw', () => {
                    const input = tf.randomNormal([1, 28, 28, 8]);
                    const filter = tf.randomNormal([3, 3, 8, 1]);
                    return [tf.depthwiseConv2d(input, filter, 1, 'same')];
                }, 15);
                document.getElementById('conv-dw').innerHTML =
                    `GPU: ${formatPerformance(results.webgpu)}, GL: ${formatPerformance(results.webgl)}, CPU: ${formatPerformance(results.cpu)}`;

            } finally {
                button.disabled = false;
                button.textContent = 'Test Convolutions';
                updateComparisonTable();
            }
        }

        async function runMemoryBenchmarks() {
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Testing...';

            try {
                const backends = ['webgpu', 'webgl', 'cpu'];
                const results = {};

                for (const backend of backends) {
                    await tf.setBackend(backend);
                    if (tf.getBackend() !== backend) continue;

                    // Test tensor creation speed
                    const createStart = performance.now();
                    const tensors = [];
                    for (let i = 0; i < 100; i++) {
                        tensors.push(tf.randomNormal([100, 100]));
                    }
                    await Promise.all(tensors.map(t => t.data()));
                    const createTime = performance.now() - createStart;

                    // Test disposal speed
                    const disposeStart = performance.now();
                    tensors.forEach(t => t.dispose());
                    const disposeTime = performance.now() - disposeStart;

                    results[backend] = {
                        create: 100 / (createTime / 1000),
                        dispose: 100 / (disposeTime / 1000)
                    };
                }

                document.getElementById('mem-upload').innerHTML =
                    `GPU: ${formatPerformance(results.webgpu?.create || 0)}, GL: ${formatPerformance(results.webgl?.create || 0)}, CPU: ${formatPerformance(results.cpu?.create || 0)}`;
                document.getElementById('mem-download').innerHTML = 'See tensor creation speeds above';
                document.getElementById('mem-copy').innerHTML = 'See tensor disposal speeds below';

            } finally {
                button.disabled = false;
                button.textContent = 'Test Memory Transfer';
            }
        }

        async function runTensorBenchmarks() {
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Testing...';

            try {
                // Small tensor operations
                let results = await benchmarkOperation('tensor-small', () => {
                    const a = tf.randomNormal([10, 10]);
                    const b = tf.randomNormal([10, 10]);
                    return [tf.add(a, b), tf.mul(a, b)];
                }, 100);
                document.getElementById('tensor-small').innerHTML =
                    `GPU: ${formatPerformance(results.webgpu)}, GL: ${formatPerformance(results.webgl)}, CPU: ${formatPerformance(results.cpu)}`;

                // Large tensor operations
                results = await benchmarkOperation('tensor-large', () => {
                    const a = tf.randomNormal([1000, 1000]);
                    return [tf.square(a)];
                }, 10);
                document.getElementById('tensor-large').innerHTML =
                    `GPU: ${formatPerformance(results.webgpu)}, GL: ${formatPerformance(results.webgl)}, CPU: ${formatPerformance(results.cpu)}`;

            } finally {
                button.disabled = false;
                button.textContent = 'Test Tensor Ops';
                updateComparisonTable();
            }
        }

        async function runCNNSpecificTest() {
            const button = document.getElementById('cnn-test-btn');
            button.disabled = true;
            button.textContent = 'Running CNN Test...';

            const progress = document.getElementById('cnn-progress');
            const results = document.getElementById('cnn-results');

            try {
                // This mimics the exact CNN operations from your trainer
                const results_data = await benchmarkOperation('cnn-pipeline', async () => {
                    // Input layer
                    const input = tf.randomNormal([1, 28, 28, 1]);

                    // Conv layer
                    const conv1 = tf.conv2d(input, tf.randomNormal([3, 3, 1, 8]), 1, 'same');
                    const relu1 = tf.relu(conv1);

                    // Pool layer
                    const pool1 = tf.maxPool(relu1, 2, 2, 'valid');

                    // Another conv
                    const conv2 = tf.conv2d(pool1, tf.randomNormal([3, 3, 8, 16]), 1, 'same');
                    const relu2 = tf.relu(conv2);

                    // Flatten and dense
                    const flatten = tf.reshape(relu2, [1, -1]);
                    const dense = tf.matMul(flatten, tf.randomNormal([flatten.shape[1], 10]));

                    return [dense];
                }, 20);

                progress.style.width = '100%';

                results.innerHTML = `
                    <h4>CNN Pipeline Performance:</h4>
                    <div>WebGPU: ${formatPerformance(results_data.webgpu)} (${results_data.webgpu > 0 ? 'Working' : 'Failed'})</div>
                    <div>WebGL: ${formatPerformance(results_data.webgl)} (${results_data.webgl > 0 ? 'Working' : 'Failed'})</div>
                    <div>CPU: ${formatPerformance(results_data.cpu)} (${results_data.cpu > 0 ? 'Working' : 'Failed'})</div>
                    <br>
                    <div class="info">This test shows the performance for the exact operations your CNN trainer uses.</div>
                `;

                // Analyze results
                analyzePerformanceIssues(results_data);

            } catch (error) {
                results.innerHTML = `<div class="fail">‚ùå CNN test failed: ${error.message}</div>`;
            } finally {
                button.disabled = false;
                button.textContent = 'Run CNN Performance Test';
                updateComparisonTable();
            }
        }

        function updateComparisonTable() {
            const tbody = document.getElementById('comparison-body');
            let html = '';

            for (const [test, results] of Object.entries(benchmarkResults)) {
                const winner = Object.keys(results).reduce((a, b) => results[a] > results[b] ? a : b);
                const analysis = analyzeResult(results);

                const winnerClass = (backend) => results[backend] === Math.max(...Object.values(results)) ? 'winner' : '';

                html += `
                    <tr>
                        <td>${test}</td>
                        <td class="${winnerClass('webgpu')}">${results.webgpu?.toFixed(0) || 'N/A'}</td>
                        <td class="${winnerClass('webgl')}">${results.webgl?.toFixed(0) || 'N/A'}</td>
                        <td class="${winnerClass('cpu')}">${results.cpu?.toFixed(0) || 'N/A'}</td>
                        <td>${winner.toUpperCase()}</td>
                        <td>${analysis}</td>
                    </tr>
                `;
            }

            if (html) {
                tbody.innerHTML = html;
            }
        }

        function analyzeResult(results) {
            const webgpu = results.webgpu || 0;
            const webgl = results.webgl || 0;
            const cpu = results.cpu || 0;

            if (webgpu > webgl && webgpu > cpu) {
                return 'üéâ WebGPU optimal';
            } else if (webgl > webgpu && webgl > cpu) {
                return '‚ö†Ô∏è WebGL better than WebGPU';
            } else if (cpu > webgpu && cpu > webgl) {
                return '‚ùå GPU slower than CPU';
            } else {
                return '‚ùì Mixed results';
            }
        }

        function analyzePerformanceIssues(cnnResults) {
            const issuesDiv = document.getElementById('performance-issues');
            const recDiv = document.getElementById('optimization-recommendations');

            let issues = [];
            let recommendations = [];

            // Check if WebGPU is significantly slower than expected
            if (cnnResults.cpu > cnnResults.webgpu * 2) {
                issues.push('üêå WebGPU is significantly slower than CPU');
                recommendations.push('‚Ä¢ Check if WebGPU is using software rendering instead of hardware');
                recommendations.push('‚Ä¢ Verify that discrete GPU is being used, not integrated graphics');
                recommendations.push('‚Ä¢ Try different browser flags: --use-vulkan=native or --use-angle=vulkan');
            }

            if (cnnResults.webgl > cnnResults.webgpu) {
                issues.push('üîÑ WebGL outperforming WebGPU (unexpected)');
                recommendations.push('‚Ä¢ WebGPU may have overhead for small operations');
                recommendations.push('‚Ä¢ Try larger batch sizes or more complex models');
                recommendations.push('‚Ä¢ Check browser WebGPU implementation maturity');
            }

            if (Math.max(...Object.values(cnnResults)) < 100) {
                issues.push('üê¢ Overall performance is low across all backends');
                recommendations.push('‚Ä¢ Update graphics drivers to latest version');
                recommendations.push('‚Ä¢ Enable hardware acceleration in browser settings');
                recommendations.push('‚Ä¢ Close other GPU-intensive applications');
            }

            // Check for specific GTX 980 Ti issues
            issues.push('üí° GTX 980 Ti Specific Notes');
            recommendations.push('‚Ä¢ GTX 980 Ti supports Vulkan but lacks some modern features');
            recommendations.push('‚Ä¢ WebGPU may have better optimization for newer architectures');
            recommendations.push('‚Ä¢ Consider testing with more complex models where WebGPU advantages show');
            recommendations.push('‚Ä¢ WebGL might be more mature/optimized for your specific GPU generation');

            issuesDiv.innerHTML = issues.map(issue => `<div class="warn">${issue}</div>`).join('');
            recDiv.innerHTML = recommendations.map(rec => `<div class="info">${rec}</div>`).join('');
        }
    </script>
</body>
</html>
